## Level3

```bash
file level3
level3: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=26a7c615f73fac182924d75acbfbe7363560cdb2, for GNU/Linux 3.2.0, not stripped
```

This is a 64bits binary this time.

## 64bits binary registers

Because it is a 64-bit (x86_64) binary, the calling convention is different from 32-bit binaries. Function arguments are not passed on the stack, but through registers:

    rdi â†’ first argument

    rsi â†’ second argument

    rdx â†’ third argument

    rcx, r8, r9 â†’ next arguments

For example, when the program calls strcmp, the two strings being compared are stored in rdi and rsi. This is why inspecting registers is essential when debugging 64-bit binaries.


## Decompiler tool

To better understand the program, an online decompiler was used:
* And also YOU SEE the **key** directly and the process which is used to parse the user input

ðŸ‘‰ https://dogbolt.org
Dogbolt allows you to upload a binary and view C-like pseudocode generated by several decompilers (such as Ghidra). While this is not the original source code, it is extremely helpful to retrace the program logic compared to raw assembly.

Reconstructing the algorithm

The decompiled pseudocode reveals the real logic of the program:

*   The user input is stored in a buffer

*   The program processes the input three characters at a time

*   Each group of three characters is passed to atoi

*   The returned integer is cast to a char

*   This character is appended to a new string

This explains why the loop increments by +3 each iteration and why many temporary variables appear in the decompiled code.

## Obfuscation, noise and decompiler particularity

A large portion of the code is intentionally useless:

*   Many unrelated functions

*   Redundant conditions

*   Confusing variable names (it comes from the decompiler generaly)

*   Multiple strcmp return value checks that all lead to failure except one

This kind of noise is commonly added in reverse engineering challenges to obfuscate the real behavior and make static and dynamic analysis harder, even though the core logic remains simple.


## Anti reverse protection and early checks

The program performs several checks before reaching the final comparison:

*   The user input must start with specific characters (for example '4' and '2')

*   If these conditions are not met, the program exits immediately

This behavior acts as a simple anti-debug / anti-display mechanism. Because the program exits early, placing a breakpoint directly on the right `strcmp` is not sufficient to understand the logic or display the computed string unless the input already follows the correct format.

## Find the key

The logic is the same that the level before.
We understand that the number 42 is the equivalent of * ASCII character.

So we have to put "42042042042042042042042042" for 9 stars.